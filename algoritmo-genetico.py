# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eZYNJb8E_opSahmfLJpvHJra66k8MV6_
"""

import random

# Constantes e parâmetros do experimento
NUM_CITIES = 10
POPULATION_SIZE = 50    # Quanto maior a população maiores possibilidades geneticas e soluções (10 baixo 50 alto)
MIXING_NUMBER = 2       # Quanto maior o valor, mais diversidade genética é introduzida.
MUTATION_RATE = 0.5    # probabilidade de um gene ser alterado, Ajuste a taxa de mutação (mais alto mais divercidade porem mais aleatorio)
MAX_GENERATIONS = 30    # Ajuste o número máximo de gerações (isso depende de cada nessecidade)
DISTANCE_MATRIX = [

    #rotas = 0Belo Horizonte, 1Contagem, 2Uberlândia, 3Juiz de Fora, 4Ribeirão das Neves, 5Betim , 6Montes Claros, 7Uberaba , 8Governador Valadares, 9Santa luzia

    [0, 19, 536, 261, 34, 30, 425, 475, 317, 24],
    [19, 0, 523, 270, 27, 17, 418, 462, 334, 41],
    [536, 523, 0, 785, 547, 506, 627, 106, 851, 558],
    [261, 271, 787, 0, 286, 280, 678, 726, 454, 284],
    [33, 28, 552, 291, 0, 46, 398, 491, 334, 33],
    [29, 17, 506, 279, 41, 0, 433, 445, 345, 52],
    [425, 415, 627, 677, 399, 432, 0, 648, 535, 433],
    [476, 463, 106, 726, 488, 446, 648, 0, 791, 498],
    [322, 336, 857, 455, 339, 351, 534, 796, 0, 313],
    [25, 39, 561, 284, 33, 54, 429, 500, 310, 0]
]

# matrix 10x10
#onde cada linha da matrix representa a distancia de cada cidade para outra


#aptidao indica o quao boa e uma solucao candidata
def calculate_fitness(route):
    total_distance = 0 #sera usada pra acumular a distancia total da rota
    for i in range(len(route) - 1): #itera sobre os indices da rota
        total_distance += DISTANCE_MATRIX[route[i]][route[i + 1]] #adiciona a total_distance a distancia entre a cidade atual e a proxima
    total_distance += DISTANCE_MATRIX[route[-1]][route[0]] #adiciona a distancia da ultima cidade
    return total_distance #retorna distancia total da rota

def generate_population():
    population = []
    for _ in range(POPULATION_SIZE):
        route = list(range(NUM_CITIES))    #cria uma lista rota
        random.shuffle(route)              #embaralha
        population.append(route)           #add
    return population                      #retorna aleatoria

def crossover(parent1, parent2):
    start, end = sorted(random.sample(range(NUM_CITIES), 2)) #seleciona aleatoriamente (primeiro maior que o segundo)
    child = [-1] * NUM_CITIES #sera preenchida que ira representar a rota do filho
    child[start:end] = parent1[start:end] #pai1
    remaining = [gene for gene in parent2 if gene not in child] #pai2
    remaining_index = 0 #inicio um indice para percorrer a lista remaining
    for i in range(NUM_CITIES):   #percorre todas as posições da rota.
        if child[i] == -1: #verifica se o gene na posicao i do filho ainda nao foi preenchido
            child[i] = remaining[remaining_index] #atribui o proximo gene disponivel da lista remaining a posicao atual do filho
            remaining_index += 1 #atualiza o indice para apontar para o proximo gente
    return child                  #filho resultante após o crossove

def mutate(route):
    if random.random() < MUTATION_RATE: #num aleatorio entre 0 e 1
        index1, index2 = random.sample(range(NUM_CITIES), 2)        #escolhemos aleatoriamente
        route[index1], route[index2] = route[index2], route[index1] #rota são trocados
    return route

def evolve(population):
    parents = sorted(population, key=calculate_fitness)[:POPULATION_SIZE // 2] #seleciona melhores com base na aptidao
    offsprings = [] #lista para decendentes
    while len(offsprings) < POPULATION_SIZE - len(parents): #gera decendentes ate o tamanho desejado
        parent1, parent2 = random.sample(parents, 2)
        offspring = crossover(parent1, parent2)
        offspring = mutate(offspring)
        offsprings.append(offspring) #add descendente a lista
    return parents + offsprings #proxima geracao

def main():
    population = generate_population() #GERA rota aleatoria
    for generation in range(MAX_GENERATIONS): #loop que itera sobre um num max de geracoes
        population = evolve(population)  #cada interacao chamamos para evoluir
        best_route = min(population, key=calculate_fitness) #encontra a melhor rota na populacao atual com base na menor distancia total percorrida
        best_distance = calculate_fitness(best_route) #distancia total da melhor rota
        print(f'Generation: {generation}, Best Distance: {best_distance}')

        # Imprimir a melhor rota e distância no final
        print("Best Route:", best_route)
        print("Best Distance:", best_distance)

if __name__ == "__main__":
    main()

